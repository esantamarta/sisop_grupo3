#!/bin/bash

#PUNTO 1: La inicializacion del entorno la hace el Start

#PUNTO 2: LOG
function log() {
	"$BINARIOS"/Logger "Validate" "$1" "$2"
}

function logInfo() {
	log "$1" "i"
}

function logAlert() {
	log "$1" "a"
}

function logError() {
	log "$1" "e"
}


############## FUNCIONES PUNTOS 3,4 Y 7 ##############

function tiene_fecha_invalida() {
	fecha=$1
	fecha_filename=$2
	patron='[0-9][0-1][0-9][0-3][0-9]'
	if [[ $fecha =~ $patron ]] && date -d "$fecha" >/dev/null 2>&1	
	then
		condicion=$(date -d "$fecha_filename" "+%s")
		fecha=$(date -d "$fecha" "+%s")
		diferencia=$(( (($fecha- $condicion) / 86400) ))
		if [ "$diferencia" -le "7" ] && [ "$diferencia" -ge "0" ]
		then
			return 1
		else
			return 0
		fi
	else
		return 0
	fi
}

function no_existe_cbu() {
	entidades=$(awk -F";" '{print $2}' $MAESTROS/"bamae.txt")
	principio_cbu=$(echo "$1" | cut -c1-3)
	o_IFS=$IFS
	IFS=$2
	for j in $entidades
	do
		if [[ $principio_cbu == $j ]]
		then
			return 1
		fi
	done
	IFS=${o_IFS}
	return 0
}

function es_archivo_repetido() {
	while read nombre;
	do
		nombre=$(basename "$nombre")
		if [[ "$1" == "$nombre" ]]
		then
			echo "Archivo $1 duplicado" 
			return 0
		fi
	done < <(find $VALIDADOS -type f)
	echo "El archivo $1 no es duplicado"
	return 1
}

function tiene_cantidad_registros_incorrecta() {
	registros_archivo=$(awk -F";" '{print $1}' $ACEPTADOS/$1)
	j=0
	cantidad_registros_header=0
	cantidad_registros=0
	for z in $registros_archivo
	do
		if [[ $j -eq 0 ]]
		then
			cantidad_registros_header=$z
		else
			cantidad_registros=$(($cantidad_registros+1))
		fi
		j=$(($j+1))
	done

	if [[ $cantidad_registros -ne $cantidad_registros_header ]]
	then	
		logInfo "Error en la cantidad de registros en el archivo $1: leidos: $cantidad_registros Cantidad informada: $cantidad_registros_header"
		return 0
	fi

	logInfo "La cantidad de registros del archivo $1 coincide con la cantidad en el campo de cabecera"
	return 1
	
}

function tiene_monto_incorrecto(){
	registros_archivo=$(awk -F";" '{print $2}' $ACEPTADOS/$1)
	j=0
	cantidad_monto_header=0
	cantidad_monto=0
	for z in $registros_archivo
	do
		if [[ $j -eq 0 ]]
		then
			cantidad_monto_header=$(echo $z | tr ',' '.')
		else
			a=$cantidad_monto
			b=$(echo $z | tr ',' '.')
			cantidad_monto=$(echo "$a + $b" | bc)
		fi
		j=$(($j+1))
	done

	if [[ $(echo "$cantidad_monto_header!=$cantidad_monto" | bc ) -eq 1 ]]

	then	
		logInfo "Error en hash total: Sumatoria: $cantidad_monto Monto informado: $cantidad_monto_header"
		return 0
	fi

	logInfo "El monto del archivo $1 coincide con el monto en el campo de cabecera"
	return 1
}


function tiene_formato_valido() {
	columnas_header=$(awk -F";" 'NR == 1 {print NF}' $ACEPTADOS/$1)
	maxima_cantidad_columnas_cuerpo=$(awk -F";" 'NR > 1 {print NF}' $ACEPTADOS/$1 | sort -nu | head -n 1)
	minima_cantidad_columnas_cuerpo=$(awk -F";" 'NR > 1 {print NF}' $ACEPTADOS/$1 | sort -nu | tail -n 1)

	if [[ columnas_header -ne 2 ]]
	then
		logInfo "El archivo $1 no tiene la cantidad de columnas correctas."
		return 0
	elif [[ maxima_cantidad_columnas_cuerpo -eq minima_cantidad_columnas_cuerpo ]]
	then
		logInfo "El archivo $1 tiene la cantidad de columnas correctas."
		return 1
	else
		logInfo "El archivo $1 no tiene la cantidad de columnas correctas."
		return 0
	fi

}

function tiene_formato_incorrecto_fecha() {
	fecha_filename=$(echo "$1" | cut -d "_" -f 2)
	fecha_filename=$(echo "$fecha_filename" | cut -d "." -f 1)
	registros_archivo=$(awk -F";" 'NR > 1 {print $1}' $ACEPTADOS/$1)
	registro=1
	for z in $registros_archivo
	do	
		fecha=$z
		if tiene_fecha_invalida $fecha $fecha_filename
		then
			logInfo "Error de formato del archivo $1 en registro nro $registro"
			return 0
		fi
		registro=$(($registro+1))
	done

	logInfo "El formato de fechas del archivo $1 es valido"
	return 1
}

function tiene_formato_incorrecto_monto() {
	registros_archivo=$(awk -F";" 'NR > 1 {print $2 ";" $3"%"}' $ACEPTADOS/$1)
	registro=1
	old_IFS=$IFS
	IFS='%'
	read -r -a registros <<< "$registros_archivo"
	for z in "${registros[@]}"
	do
		monto=$(echo "$z" | cut -d ";" -f 1)
		estado=$(echo "$z" | cut -d ";" -f 2)
		monto=$(echo $monto | tr ',' '.')
		if [[ ! $monto == '' ]]
		then
			if [[ $estado == "Pendiente" ]]
			then
				if [[  $(echo "$monto<=0" | bc ) -eq 1  ]]
				then
				logInfo "Error de formato del archivo $1 en registro nro $registro"
					return 0
				fi
			elif [[ $estado == "Anulada" ]]
			then
				if [[ $(echo "$monto>=0" | bc ) -eq 1 ]]
				then
				logInfo "Error de formato del archivo $1 en registro nro $registro"
					return 0
				fi
			fi
		else
			logInfo "Error de formato del archivo $1 en registro nro $registro"
			return 0
		fi
		registro=$(($registro+1))
	done
	IFS=${old_IFS} 
	logInfo "El monto del archivo $1 tiene formato correcto"
	return 1
}

function tiene_formato_incorrecto_estado() {
	registros_archivo=$(awk -F";" 'NR > 1 {print $3}' $ACEPTADOS/$1)
	registro=1
	for z in $registros_archivo
	do	
		if  ! { [[  $z == "Pendiente" ]] || [[  $z == "Anulada" ]];}
		then
			logInfo "Error de formato del archivo $1 en el registro nro $registro"
			return 0
		fi
		registro=$(($registro+1))
	done

	logInfo "El formato del campo estado del archivo $1 es correcto."
	return 1
}

function tiene_formato_incorrecto_cbus() {
	registros_archivo=$(awk -F";" 'NR > 1{print $4 ";" $5"%"}' $ACEPTADOS/$1)
	registro=1
	old_IFS=$IFS
	IFS='%'
	read -r -a registros <<< "$registros_archivo"
	for z in "${registros[@]}"
	do
		cbu_origen=$(echo "$z" | cut -d ";" -f 1)
		cbu_destino=$(echo "$z" | cut -d ";" -f 2)
		pattern='[0-9]{22}'
		if [[ $cbu_origen =~ $pattern ]] && [[ $cbu_destino =~ $pattern ]]
		then
			if [[ $(echo "$cbu_origen!=$cbu_destino" | bc ) -eq 1 ]]
			then
				if  no_existe_cbu $cbu_origen "${old_IFS}"
				then
					logInfo "Error de formato del archivo $1 en registro nro $registro"
					return 0
				fi

				if no_existe_cbu $cbu_destino "${old_IFS}"
				then
					logInfo "Error de formato del archivo $1 en registro nro $registro"
					return 0
				fi
			else
				logInfo "Error de formato del archivo $1 en registro nro $registro"
				return 0
			fi
		else
			logInfo "Error de formato del archivo $1 en registro nro $registro"
			return 0
		fi
		registro=$(($registro+1))
	done
	IFS=${old_IFS}
	logInfo "Los cbus del archivo $1 tienen formato correcto"
	return 1
}


function procesar_aceptados() {
	if [ ! -f "$MAESTROS"/"bamae.txt" ] 
	then
		logError "No se encuentra el archivo de maestros."
		return 1
	fi
	archivos_procesados=''
	find $ACEPTADOS -type f | while read FILE
	do
		i=$(basename "$FILE")
		if es_archivo_repetido "$i" "$archivos_procesados";
		then
			mv"$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi	

		if tiene_formato_valido "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi	
		
		if tiene_cantidad_registros_incorrecta "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi	
		
		if tiene_monto_incorrecto "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi
		
		if tiene_formato_incorrecto_fecha "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi

		if tiene_formato_incorrecto_estado "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi

		if tiene_formato_incorrecto_monto "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi
		
		if tiene_formato_incorrecto_cbus "$i";
		then
			mv "$ACEPTADOS/$i" $RECHAZADOS
			archivos_procesados=$(echo "$archivos_procesados$i;")
			continue
		fi
		mv "$ACEPTADOS/$i" "$VALIDADOS"
		archivos_procesados=$(echo "$archivos_procesados$i;")
	done 
}

############## FUNCIONES PUNTOS 3,4 Y 7 ##############






############## FUNCIONES PUNTOS 5,6 Y 7 ##############

#Crear archivo de salida en base a los aceptados validos, y crear archivo de salida en procesados/proc
function crear_archivos_salida() {

	mkdir -p "$REPORTES"/transfer
	ARR_ACEPTADOS=("$ACEPTADOS"/*)
	for archivo in  "${ARR_ACEPTADOS[@]}"
	do
		test -f "$archivo" || continue
		crear_archivo_salida "$archivo"
	done
}


#Recibe un archivo de novedades y lo usa para armar la salida
#Archivo de salida en directorio reportes/transfer
#Mueve el archivo procesado a validados/proc
function crear_archivo_salida() {
	INPUT=$(basename "$1")
	ARCHIVO="$1"

	FUENTE=$(basename "$ARCHIVO")

	logInfo "Procesando archivo $FUENTE"

	ARCHIVO_MAESTROS=$(basename "$MAESTROS")
	HEADER=true
	while read -r linea
	do

		if [ $HEADER == true ]
		then
			HEADER=false
			continue
		fi

		FECHA=$(cut -d';' -f1 <<< "$linea")
		IMPORTE=$(cut -d';' -f2 <<< "$linea")
		ESTADO=$(cut -d';' -f3 <<< "$linea")
		CBU_ORIGEN=$(cut -d';' -f4 <<< "$linea")
		CBU_DESTINO=$(cut -d';' -f5 <<< "$linea")
		COD_ORIGEN=${CBU_ORIGEN:0:3}
		COD_DESTINO=${CBU_DESTINO:0:3}
		ENTIDAD_ORIGEN=$(grep "$COD_ORIGEN" "$MAESTROS"/"bamae.txt" | cut -d';' -f1)
		ENTIDAD_DESTINO=$(grep "$COD_DESTINO" "$MAESTROS"/"bamae.txt" | cut -d';' -f1)

		ARCHIVO_SALIDA="$REPORTES""/transfer/""$FECHA"".txt"

		echo "$FUENTE"\;"$ENTIDAD_ORIGEN"\;"$COD_ORIGEN"\;"$ENTIDAD_DESTINO"\;"$COD_DESTINO"\;"$FECHA"\;"$IMPORTE"\;"$ESTADO"\;"$CBU_ORIGEN"\;"$CBU_DESTINO" >> "$ARCHIVO_SALIDA"
		
	done < "$ARCHIVO"

	mv "$ARCHIVO" "$VALIDADOS""/proc"
	logInfo "El archivo fue movido a $VALIDADOS""/proc"
}


############## FIN FUNCIONES PUNTOS 5,6 Y 7 ##############



logInfo "Iniciando Validate"


#PUNTO 3: Validar archivos (repetidos -ver PUNTO 7 -, consistencia de datos, etc)


#PUNTO 4: Mover archivos rechazados y loguear el motivo

procesar_aceptados

#PUNTOS 5, 6 y 7
crear_archivos_salida


logInfo "Validate ended"