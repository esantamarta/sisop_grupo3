#!/bin/bash

#Punto 1. Ambiente– sprint 1
#Ningún comando puede ser ejecutado sin la inicialización del ambiente 
#Para determinar el directorio de novedades, aceptados, rechazados, etc. se deben leer las variables de ambiente.
#echo $$

############Inicializacion la utilizo para probar, cuando se integre quitar################
#GRUPO=$PWD"/sisoptest"
#BINARIOS=$GRUPO"/BIN"
#MAESTROS=$GRUPO"/MAE"
##NOVEDADES=$GRUPO"/nov"
#ACEPTADOS=$GRUPO"/OK"
#RECHAZADOS=$GRUPO"/NOK"
#VALIDADOS=$GRUPO"/PROC"
#REPORTES=$GRUPO"/INFO"
#LOG=$GRUPO"/LOG"
############################################################################################

#REVISAR QUE LAS VARIABLES DE AMBIENTE SEAN LAS MISMAS QUE LAS SETEADAS EN EL INICIALIZADOR
VARIABLES_AMBIENTE=($GRUPO $BINARIOS $MAESTROS $NOVEDADES $ACEPTADOS $RECHAZADOS $VALIDADOS $REPORTES $LOG)
COUNT_VARIABLES_AMBIENTE=9

# Valida que el ambiente haya sido inicializado previamente
# Recibe el array de variables de ambiente y el contador de variables
# Si alguna variable esta vacia, el size del array es menor al contador
function validar_ambiente_inicializado() {
	if [ ${#VARIABLES_AMBIENTE[@]} -ne $2 ] 
		then
		#echo "LOG: AMBIENTE NO INICIALIZADO"
		#Si el ambiente no esta inicializado no puedo guardar en log
		echo "El ambiente no se encuentra inicializado. Saliendo..."
		exit 1 #corta la ejecucion del programa
	fi
}


function log() {
	./Logger "Daemon" "$1" "$2"
}

function logInfo() {
	log "$1" "i"
}

function logAlert() {
	log "$1" "a"
}

function logError() {
	log "$1" "e"
}

function es_archivo_ilegible () {
	NOVEDAD=$NOVEDADES/$1
	if [ -r "$NOVEDAD" ]
	then
		logInfo "El archivo $1  es legible"
		return 1
	else
		logInfo "El archivo $1 no es legible"
		return 0
	fi
}



# Recibe un archivo, devuelve true si es vacio
function es_archivo_vacio() {

	NOVEDAD=$NOVEDADES/$1
	if [ -s "$NOVEDAD" ]
	then
		logInfo "El archivo $1 no esta vacio"
		return 1
	else
		logInfo "El archivo $1 esta vacio"
		return 0
	fi
}

function es_archivo_irregular() {

	NOVEDAD=$NOVEDADES/$1
	if [ -f "$NOVEDAD" ]
	then
		logInfo "El archivo $1 es regular"
		return 1
	else
		logInfo "El archivo $1 no regular"
		return 0
	fi
}

function tiene_formato_incorrecto() {

	pattern='[A-Z]*_[0-9]*.txt'
	if [[ $1 =~ $pattern ]];
	then
		logInfo "$1 tiene formato correcto"
		return 1
	else
		logInfo "$1 tiene formato incorrecto"
		return 0
	fi
}


function no_existe_entidad() {
	entidad=$(echo "$1" | cut -d "_" -f 1)
	for j in $2
	do
		if [ $entidad == $j ]
		then
			logInfo "La entidad del archivo $1 es valida"
			return 1
		fi
	done
	logInfo "La entidad del archivo $1 no es valida"
	return 0
}


#mover_archivo origen destino
#Si el archivo ya existe en destino, le agrega un indice
#ej: archivo.txt, archivo1.txt, archivo2.txt
function mover_archivo() {
	
	
	FILE=$1
	FILENAME=$(basename "$FILE")
	DEST=$2
	FILENAME_NOEXT=${FILENAME%.*}
	EXT=${FILE##*.}
	logInfo "Moviendo $FILENAME al directorio $DEST"
	if [[ ! -e "$DEST/$FILENAME" ]]; then
	      mv "$FILE" "$DEST"
	else
	      NUM=1
	      while [[ -e "$DEST"/"$FILENAME_NOEXT"_"$NUM"."$EXT" ]]; do
	            (( NUM++ ))
	      done
	      logAlert "$FILENAME renombrado a $FILENAME_NOEXT"_"$NUM"."$EXT"
	      mv "$FILE" "$DEST"/"$FILENAME_NOEXT"_"$NUM"."$EXT" 
	fi 
}

function es_fecha_invalida() {
	fecha=$(echo "$1" | cut -d "_" -f 2)
	fecha=$(echo "$fecha" | cut -d "." -f 1)
	patron='[0-9][0-1][0-9][0-3][0-9]'
	if [[ $fecha =~ $patron ]] && date -d "$fecha" >/dev/null 2>&1	
	then
		condicion=$(date -d "now" "+%s")
		fecha=$(date -d "$fecha" "+%s")
		diferencia=$(( ((condicion - fecha) / 86400) ))
		if [ "$diferencia" -lt "15" ] && [ "$diferencia" -gt "-1" ]
		then
			logInfo "La fecha del archivo $1 es valida"
			return 1
		else
			logInfo "La fecha del archivo $1 no es valida"
			return 0
		fi
	else
		logInfo "La fecha del archivo $1 no es valida"
		return 0
	fi
}


# Recibe una lista de archivos de novedades
# Valida que sean archivos validos
function procesar_novedades() {
	if [ ! -f "$MAESTROS"/"bamae.txt" ] 
	then
		logError "No se encuentra el archivo de maestros. Las novedades no seran procesadas"
		return 1
	fi
	entidades=$(awk -F";" '{print $1}' $MAESTROS/"bamae.txt")

	FILES=$1
	#for i in ${FILES[@]}
	find $NOVEDADES -type f | while read FILE
	do
		i=$(basename "$FILE")
		if es_archivo_ilegible "$i"
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi	

		if es_archivo_vacio "$i";
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi	
		
		if es_archivo_irregular "$i";
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi
		
		if tiene_formato_incorrecto "$i";
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi
		
		if no_existe_entidad "$i" "$entidades";
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi

		if es_fecha_invalida "$i";
		then
			mover_archivo "$NOVEDADES/$i" $RECHAZADOS
			continue
		fi
		mover_archivo "$NOVEDADES/$i" $ACEPTADOS
	done 
}

function invocar_validar_aceptados() {
	./Start Validate
	STATUS="$?"
	if [ "$STATUS" -eq 10 ] 
	then
		MSG="Invocacion pospuesta para el siguiente ciclo"
	else
		PID="$(pidof -x Validate)"
		MSG="Validate iniciado con id: $PID"
	fi
	logInfo "$MSG" 
}




#Valida si el ambiente esta inicializado, sino sale del programa
validar_ambiente_inicializado $VARIABLES_AMBIENTE $COUNT_VARIABLES_AMBIENTE

touch "$LOG"/"Daemon.log" 

logInfo " "
logInfo "Daemon iniciado con process id: $$"
logInfo " "


# 1s = 1 segundo
# 1m = 1 minuto 
WAIT=6s  

LOOPS=0


while true
do
	LOOPS=$(($LOOPS+1))
	logInfo "Loop nro: $LOOPS" #PUNTO 4
	
#funcionalidad del daemon

NOV_FILES="$(ls $NOVEDADES)"
if [ -z "$NOV_FILES" ]
	then
	logInfo "No hay novedades"
	invocar_validar_aceptados "$(ls $ACEPTADOS)"
else
	logInfo "Hay novedades para procesar"
	procesar_novedades "$NOV_FILES"
fi

	sleep $WAIT
done


